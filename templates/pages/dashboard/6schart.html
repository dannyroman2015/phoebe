{{define "6schart"}}
<div id="legend" style="width: 100%; max-width: 100%; margin: 0 auto"></div>
<div id="chart6s" style="width: 100%; max-width: 100%; margin: 0 auto"></div>

<script>
  

  const margin6s = {top: 30, right: 30, bottom: 30, left: 40}
  const width6s = 900
  const height6s = 350
  const innerWidth6s = width6s - margin6s.left - margin6s.right
  const innerHeight6s = height6s - margin6s.top - margin6s.bottom

  const svg6s = d3.select("#chart6s")
    .append("svg")
    .attr("viewBox", [0, 0, width6s, height6s])

  const innerChart6s = svg6s.append("g")
    .attr("transform", `translate(${margin6s.left}, ${margin6s.top})`)

  var s6dates = {{.s6dates}}
  var s6areas = {{.s6areas}}
  var s6data = {{.s6data}}

  const xScale6s = d3.scaleBand()
    .domain(s6areas)
    .range([0, innerWidth6s])
    .padding(0.01);

  const xAxis = d3.axisBottom(xScale6s)

  innerChart6s.append("g")
    .attr("transform", `translate(0, ${innerHeight6s})`)
    .call(xAxis)
    .call(g => g.select(".domain").remove())

  const yScale6s = d3.scaleBand()
    .domain(s6dates)
    .range([innerHeight6s, 0])
    .padding(0.01);

  const yAxis = d3.axisLeft(yScale6s)

  innerChart6s.append("g")
    .call(yAxis)
    .call(g => g.select(".domain").remove())

 
  const colorScale6s = d3.scaleThreshold([1, 2, 3, 4, 5, 6, 7, 8, 9], d3.schemeRdYlGn[9]);
  
  const tooltip = d3.select("#chart6s")
    .append("div")
    .attr("class", "tooltip")
    .style("opacity", 0)
    .style("background-color", "white")
    .style("border", "solid")
    .style("border-width", "2px")
    .style("border-radius", "5px")
    .style("padding", "5px")

  const mouseover = (e, d) => {
    tooltip.style("opacity", 1)
  }

  const mousemove = (e, d) => {
    tooltip
      .html("The exact value of <br>this cell is: " + d.Score)
      .style("left", (e.x)/2 + "px")
      .style("top", (e.y)/2 + "px")
  }

  const mouseleave = (d) => {
    tooltip.style("opacity", 0)
  }

  innerChart6s
    .selectAll()
    .data(s6data)
    .join("rect")
      .attr("x", d => xScale6s(d.Area))
      .attr("y", d => yScale6s(d.Date))
      .attr("width", xScale6s.bandwidth())
      .attr("height", yScale6s.bandwidth())
      .style("fill", d => colorScale6s(d.Score))
    .on("mouseover", mouseover)
    .on("mousemove", mousemove)
    .on("mouseleave", mouseleave)

    legend.append(Legend(d3.scaleThreshold([1, 2, 3, 4, 5, 6, 7, 8, 9], d3.schemeRdYlGn[9]), {
      title: "Score Range",
      tickSize: 0
    }))  

  function Legend(color, {
    title,
    tickSize = 6,
    width = 320, 
    height = 44 + tickSize,
    marginTop = 18,
    marginRight = 0,
    marginBottom = 16 + tickSize,
    marginLeft = 0,
    ticks = width / 64,
    tickFormat,
    tickValues
    } = {}) {

    function ramp(color, n = 256) {
      const canvas = document.createElement("canvas");
      canvas.width = n;
      canvas.height = 1;
      const context = canvas.getContext("2d");
      for (let i = 0; i < n; ++i) {
        context.fillStyle = color(i / (n - 1));
        context.fillRect(i, 0, 1, 1);
      }
      return canvas;
    }

    const svg = d3.create("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", [0, 0, width, height])
        .style("overflow", "visible")
        .style("display", "block");

    let tickAdjust = g => g.selectAll(".tick line").attr("y1", marginTop + marginBottom - height);
    let x;

    // Continuous
    if (color.interpolate) {
      const n = Math.min(color.domain().length, color.range().length);

      x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));

      svg.append("image")
          .attr("x", marginLeft)
          .attr("y", marginTop)
          .attr("width", width - marginLeft - marginRight)
          .attr("height", height - marginTop - marginBottom)
          .attr("preserveAspectRatio", "none")
          .attr("xlink:href", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());
    }

    // Sequential
    else if (color.interpolator) {
      x = Object.assign(color.copy()
          .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),
          {range() { return [marginLeft, width - marginRight]; }});

      svg.append("image")
          .attr("x", marginLeft)
          .attr("y", marginTop)
          .attr("width", width - marginLeft - marginRight)
          .attr("height", height - marginTop - marginBottom)
          .attr("preserveAspectRatio", "none")
          .attr("xlink:href", ramp(color.interpolator()).toDataURL());

      // scaleSequentialQuantile doesnâ€™t implement ticks or tickFormat.
      if (!x.ticks) {
        if (tickValues === undefined) {
          const n = Math.round(ticks + 1);
          tickValues = d3.range(n).map(i => d3.quantile(color.domain(), i / (n - 1)));
        }
        if (typeof tickFormat !== "function") {
          tickFormat = d3.format(tickFormat === undefined ? ",f" : tickFormat);
        }
      }
    }

    // Threshold
    else if (color.invertExtent) {
      const thresholds
          = color.thresholds ? color.thresholds() // scaleQuantize
          : color.quantiles ? color.quantiles() // scaleQuantile
          : color.domain(); // scaleThreshold

      const thresholdFormat
          = tickFormat === undefined ? d => d
          : typeof tickFormat === "string" ? d3.format(tickFormat)
          : tickFormat;

      x = d3.scaleLinear()
          .domain([-1, color.range().length - 1])
          .rangeRound([marginLeft, width - marginRight]);

      svg.append("g")
        .selectAll("rect")
        .data(color.range())
        .join("rect")
          .attr("x", (d, i) => x(i - 1))
          .attr("y", marginTop)
          .attr("width", (d, i) => x(i) - x(i - 1))
          .attr("height", height - marginTop - marginBottom)
          .attr("fill", d => d);

      tickValues = d3.range(thresholds.length);
      tickFormat = i => thresholdFormat(thresholds[i], i);
    }

    // Ordinal
    else {
      x = d3.scaleBand()
          .domain(color.domain())
          .rangeRound([marginLeft, width - marginRight]);

      svg.append("g")
        .selectAll("rect")
        .data(color.domain())
        .join("rect")
          .attr("x", x)
          .attr("y", marginTop)
          .attr("width", Math.max(0, x.bandwidth() - 1))
          .attr("height", height - marginTop - marginBottom)
          .attr("fill", color);

      tickAdjust = () => {};
    }

    svg.append("g")
        .attr("transform", `translate(0,${height - marginBottom})`)
        .call(d3.axisBottom(x)
          .ticks(ticks, typeof tickFormat === "string" ? tickFormat : undefined)
          .tickFormat(typeof tickFormat === "function" ? tickFormat : undefined)
          .tickSize(tickSize)
          .tickValues(tickValues))
        .call(tickAdjust)
        .call(g => g.select(".domain").remove())
        .call(g => g.append("text")
          .attr("x", marginLeft)
          .attr("y", marginTop + marginBottom - height - 6)
          .attr("fill", "currentColor")
          .attr("text-anchor", "start")
          .attr("font-weight", "bold")
          .attr("class", "title")
          .text(title));

    return svg.node();     
  }
</script>
{{end}}